\documentclass[11pt]{article}
\renewcommand{\baselinestretch}{1.05}
\usepackage{amsmath,amsthm,verbatim,amssymb,amsfonts,amscd, graphicx}
\usepackage{graphics}
\topmargin0.0cm
\headheight0.0cm
\headsep0.0cm
\oddsidemargin0.0cm
\textheight23.0cm
\textwidth16.5cm
\footskip1.0cm
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem*{surfacecor}{Corollary 1}
\newtheorem{conjecture}{Conjecture} 
\newtheorem{question}{Question} 
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\let\mbb\boldsymbol
\renewcommand\boldsymbol{\mbb}
\renewcommand{\arraystretch}{2.0}
\renewcommand{\a}{\"{a}}
\renewcommand{\o}{\"{o}}
\renewcommand{\u}{\"{u}}
\newcommand{\beequal}{\mathop{=}\limits^!}

\begin{document}

\title{Numerische Mathematik f\u r Ingenieure (SS 14) - \"{U}bung 1}
\author{Merikan Koyun \& Julian Andrej}
\maketitle

\textbf{T1. Gnomesort}\\
\begin{itemize}
\item[a)]
\begin{align*}
(2, 5, 3, 6, 4, 1, 7)\\
(2, 3, 5, 6, 4, 1, 7)\\
(2, 3, 5, 4, 6, 1, 7)\\
(2, 3, 4, 5, 6, 1, 7)\\
(2, 3, 4, 5, 1, 6, 7)\\
(2, 3, 4, 1, 5, 6, 7)\\
(2, 3, 1, 4, 5, 6, 7)\\
(2, 1, 3, 4, 5, 6, 7)\\
(1, 2, 3, 4, 5, 6, 7)\\
\end{align*}


\item[b)]

\textbf{G\u nstigster Fall}\\
Bei $n$ paarweise verschiedenen Zahlen in geordneter Reihenfolge ergeben sich $i_g = n-1$ Inkrementierungen und $v_g=0$ Vertauschungen. Da die Zahlen geordnet sind, tritt nur \verb!if! $a_{i-1}\leq a_i$ ein. Anfangs gilt $i_{init}\leftarrow 2$. Es wird nicht mehr inkrementiert, wenn $i=n+1$. Es werden also $ i_g= i - i_{init}= n+1-2 = n-1$ Inkrementierungen durchgef\u hrt.\vspace{0.3cm}

\textbf{Ung\u nstigster Fall}\\
Bei $n$ paarweise verschiedenen Zahlen in absteigender Reihenfolge ergeben sich $v_u=\sum_{i=1}^{n-1} i$ Vertauschungsoperationen.
Sind die Zahlen in absteigender Reihenfolge angeordnet, so ist f\u r jede Zahl eine maximale Anzahl an Sortierungen notwendig.

Bei maximaler Unordnung wird die Zahl an Index $i$ ($i\leq n$) immer p\a rchenweise nach links durchgetauscht, bis ihr Index $i=1$ ist. Eben genannte Operation wird $n-1$ mal durchgef\u hrt, da der Algorithmus mit $i \leftarrow 2$ initialisiert wird. Also f\u r eine Zahl bei Index $i$ sind $i-1$ Tauschoperationen notwendig. Damit l\a sst sich die Anzahl an Tauschoperationen als folgende Summe schreiben:
\begin{equation}
v_u = \sum_{i=2}^{n} (i-1) = \sum_{i=1}^{n-1} i
\end{equation}\vspace{0.3cm}

Eine Inkrementierung w\a hrend des eigentlichen Sortierens findet nur dann statt, wenn 2 oder mehrere Zahlen von Beginn des Vektors an aufsteigend sortiert sind. Mathematisch ausgedr\u ckt treten also w\a hrend des Sortierprozesses genau $n-1$ Sequenzen auf, f\u r die gilt $\forall k\in \{1,...,n-1\}$
\begin{equation}
a_i < a_j, \quad \, i\in\{1,...,k\},\quad j=i+1 \text{ .}
\end{equation}
Da nur in diesen F\a llen jeweils $k$-mal inkrementiert werden muss, ergibt sich trivialerweise:
\begin{equation}
i_u = \sum_{k=1}^{n-1} k
\end{equation}

\end{itemize}
 
\end{document}